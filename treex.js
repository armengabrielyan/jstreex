var treeX = (function (window, $, _, undefined) {
  var treeX = {};
  treeX.wrapper = $('<div>');
  treeX.folderIcon = 'user';
  treeX.itemIcon = 'folder';
  treeX.data = [];
  treeX.selected = null;
  treeX.refMap = {};
  treeX.expandedLevel;
  treeX.openedNodes = [];
  treeX.maxExpandLevel = 0;

  var breadCrumbs = [];
  treeX.breadCrumbTemplate = '<a data-id="<%= id%>"><%= text%></a>';
  /**
   * Breadcrumbs change handler
   * @param breadCrumbs
   */
  treeX.breadCrumbWatcher = function (breadCrumbs) {
    console.info('breadCrumbs', breadCrumbs);
  };

  /**
   * Breadcrumb click handler
   * @param node
   */
  treeX.breadCrumbClick = function(node){
    treeX.selectNode(node.id);
  };

  /**
   * node select handler
   * @param node
   */
  treeX.onNodeSelect = function(node){};

  treeX.setOnNodeSelect = function(callback){
    if(_.isFunction(callback)){
      this.onNodeSelect = callback;
    }
    return this;
  };

  /**
   * Sets tree data
   * @param data
   */
  treeX.setData = function(data){
    this.data = myData2JsTree(data);
    return this;
  };

  /**
   * Sets tree data
   * @param data
   */
  treeX.setBreadCrumbTemplate = function(template){
    this.breadCrumbTemplate = template;
    return this;
  };

  /**
   * Returns shift in pixels for given expand level
   * @param level
   * @returns {number}
   */
  treeX.getTreeShift = function(level){
    return -30 * Math.max(0, level - 3);
  };

  /**
   * Expand level change animation
   * @param ms
   * @param shift
   * @param elem
   */
  treeX.animate = function(ms,shift,elem){
     var element =  _.isEmpty(elem) ? treeX.wrapper : $(elem);
     element.animate({
        marginLeft : shift
     },ms) ;
  };

  /**
   * Selects node by given ID
   * @param nodeId
   * @returns {boolean}
   */
  treeX.selectNode = function(nodeId){
      if(treeX.selected && nodeId == treeX.selected.id){
          return false;
      }
      treeX.wrapper.jstree('deselect_all', true);
      treeX.wrapper.jstree('select_node', nodeId);
  };

  /**
   * Mapper to convert my data node to jstree acceptable form
   * @param node
   * @returns {{id: (*|folders.id|string), text: (folders.title|*|string|Function), description: (*|null), icon: (*|CSSStyleDeclaration.icon|string), state: {opened: (folders.expanded|*|boolean), disabled: (*|boolean), selected: (*|boolean)}, children: (folders.sub|*|Function|HTMLElement[]|Array), li_attr: {}, a_attr: {}}}
   */
  treeX.dataMapper = function (node) {
    var defaultIcon = (node.sub && node.sub.length) ? treeX.folderIcon : treeX.itemIcon;
    return {
      id: node.id, // will be autogenerated if omitted
      text: node.title || node.text, // node text
      description: node.description || null, // node text
      icon: node.icon || defaultIcon,  // string for custom
      state: {
        opened: node.expanded || node.opened || false,  // is the node open
        disabled: node.disabled || false,  // is the node disabled
        selected: node.selected || false  // is the node selected
      },
      children: node.sub || node.children || [],  // array of strings or objects
      li_attr: {},  // attributes for the generated LI node
      a_attr: {}  // attributes for the generated A node
    }
  };

  /**
   * Convert my data tree to jstree acceptable form
   * @param data
   * @returns {*}
   */
  function myData2JsTree(data, parentId) {
    var mappedNode;
    if (_.isArray(data)) {
      mappedNode = _.map(data, function(child, index, context){
        return myData2JsTree(child, parentId);
      });
    } else if (_.isObject(data)) {
      mappedNode = treeX.dataMapper(data);

      treeX.refMap[mappedNode.id] = mappedNode;
      treeX.refMap[mappedNode.id].__parentId = parentId
      treeX.refMap[mappedNode.id].__level = (treeX.refMap[parentId] ? treeX.refMap[parentId].__level : 0) + 1;

      mappedNode.children = myData2JsTree(mappedNode.children, mappedNode.id);
    } else {
      mappedNode = data;
    }
    return mappedNode;
  }

  /**
   *
   * @param wrapper element to append to the tree
   * @param data tree data
   * @returns {*|HTMLElement}
   */
  treeX.appendTo = function(wrapper, data){
    if(data){
      this.setData(data);
    }
    $(wrapper).append(this.wrapper);

    this.wrapper
      .jstree({
        'core' : {
          'data': this.data
        }
      })
      .on('select_node.jstree', onNodeSelect)
      .on('open_node.jstree', onBeforeExpand)
      .on('after_close.jstree', onAfterCollapse)
    return $(wrapper);
  };

  /**
   * set callback to handle breadcrumbs change
   * @param watcher
   * @returns {treeX}
   */
  treeX.setBreadCrumbWatcher = function(watcher){
    if(_.isFunction(watcher)){
      this.breadCrumbWatcher = watcher;
    }
    return this;
  };

  /**
   * add event handler for breadcrumb click
   * @param callback
   */
  treeX.onBreadCrumbClick = function(callback){
    if(_.isFunction(callback)){
      treeX.breadCrumbClick = callback;
    }
  };

  function onNodeSelect(node, selected, event){
    treeX.selected = selected.node;
    var breadcrumbIds = _.clone(selected.node.parents).reverse();
    breadcrumbIds.shift();
    breadcrumbIds.push(selected.node.id);
    updateBreadCrumbs(breadcrumbIds);
    treeX.onNodeSelect(treeX.selected);
    treeX.animate(500,treeX.getTreeShift(treeX.refMap[treeX.selected.id].__level));
  }

  function getTreeExpandLevelExceptOfNode(node){
      treeX.openedNodes = [];
      treeX.openedNodes = getOpenedNodes();
      treeX.maxExpandLevel = getMaxLevel(treeX.openedNodes);
      treeX.animate(500,treeX.getTreeShift(treeX.maxExpandLevel));
  }

  function getOpenedNodes(){
      var openedNodes = [];
      _.each(treeX.refMap,function(node){
         if(node.state.opened){
             openedNodes.push(node);
         }
      });
      return openedNodes;
  }

  function getMaxLevel(openedNodes){
    if(_.isEmpty(openedNodes)){
      return 0;
    }

    var levels = {};
    _.each(openedNodes, function(node){
      levels[node.__level] = true;
    });

    var i;
    for(i=1;i<= _.size(levels);i++){
      if(!levels[i]){
        return i;
      }
    }
    return i-1;
  }

  function updateBreadCrumbs(breadcrumbIds){
    treeX.breadCrumbs = [];

    var crumb, node;

    _.each(breadcrumbIds, function(iterator){
      node = treeX.refMap[iterator];
      if(_.isFunction(treeX.breadCrumbTemplate)){
        crumb = treeX.breadCrumbTemplate(node);
      } else {
        crumb = _.template(treeX.breadCrumbTemplate)(node);
      }
      crumb = $(crumb);
      crumb.on('click', function(event){
        var id = $(event.target).data('id');
        treeX.breadCrumbClick(treeX.refMap[id]);
      });
      treeX.breadCrumbs.push(crumb);
    });
    if(_.isFunction(treeX.breadCrumbWatcher)){
      treeX.breadCrumbWatcher(treeX.breadCrumbs);
    }
  }

  function onBeforeExpand(node, data){
    treeX.refMap[data.node.id].state.opened = true;
    getTreeExpandLevelExceptOfNode(data.node);
  }

  function onAfterCollapse(node, data){
    treeX.refMap[data.node.id].state.opened = false;
    getTreeExpandLevelExceptOfNode(data.node);
  }

  return function () {
    return treeX;
  };

  return treeX;
})(window, jQuery, _);
